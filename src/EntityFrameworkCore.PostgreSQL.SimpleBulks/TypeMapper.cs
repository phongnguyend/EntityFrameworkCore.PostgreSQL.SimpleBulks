using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace EntityFrameworkCore.PostgreSQL.SimpleBulks;

public static class TypeMapper
{
    private static readonly ConcurrentDictionary<Type, string> _mappings = new ConcurrentDictionary<Type, string>();

    static TypeMapper()
    {
        ConfigurePostgreSQLType<bool>("bool");
        ConfigurePostgreSQLType<DateTime>("timestamp");
        ConfigurePostgreSQLType<DateTimeOffset>("timestamptz");
        ConfigurePostgreSQLType<decimal>("numeric(38, 20)");
        ConfigurePostgreSQLType<double>("float8");
        ConfigurePostgreSQLType<Guid>("uuid");
        ConfigurePostgreSQLType<short>("int2");
        ConfigurePostgreSQLType<int>("int4");
        ConfigurePostgreSQLType<long>("int8");
        ConfigurePostgreSQLType<float>("float4");
        ConfigurePostgreSQLType<string>("text");
    }

    public static void ConfigurePostgreSQLType<T>(string postgreSqlType)
    {
        ConfigurePostgreSQLType(typeof(T), postgreSqlType);
    }

    public static void ConfigurePostgreSQLType(Type type, string postgreSqlType)
    {
        _mappings[type] = postgreSqlType;
    }

    public static string ToPostgreSQLType(this Type type)
    {
        if (type.IsEnum)
        {
            return "int4";
        }

        var sqlType = _mappings.TryGetValue(type, out var value) ? value : "text";
        return sqlType;
    }

    public static string GenerateTempTableDefinition<T>(string tableName, IReadOnlyCollection<string> propertyNames,
        IReadOnlyDictionary<string, string> columnNameMappings,
        IReadOnlyDictionary<string, string> columnTypeMappings,
        bool addIndexNumberColumn = false,
        Discriminator discriminator = null)
    {
        var sql = new StringBuilder();

        sql.AppendFormat("CREATE TEMPORARY TABLE {0} (", tableName);

        var i = 0;
        foreach (var propName in propertyNames)
        {
            if (i > 0)
            {
                sql.Append(",");
            }

            var propType = PropertiesCache<T>.GetPropertyUnderlyingType(propName);

            sql.Append($"\n\t\"{GetDbColumnName(propName, columnNameMappings)}\"");
            var sqlType = GetDbColumnType(propName, propType, columnTypeMappings);
            sql.Append($" {sqlType} NULL");

            i++;
        }

        if (addIndexNumberColumn)
        {
            if (i > 0)
            {
                sql.Append(",");
            }

            sql.Append($"\n\t\"{Constants.AutoGeneratedIndexNumberColumn}\"");
            var sqlType = typeof(long).ToPostgreSQLType();
            sql.Append($" {sqlType} NULL");

            i++;
        }

        if (discriminator != null && !propertyNames.Contains(discriminator.PropertyName))
        {
            if (i > 0)
            {
                sql.Append(",");
            }

            sql.Append($"\n\t\"{GetDbColumnName(discriminator.PropertyName, columnNameMappings)}\"");
            sql.Append($" {discriminator.ColumnType} NULL");

            i++;
        }

        sql.Append("\n);");

        return sql.ToString();
    }

    private static string GetDbColumnName(string columName, IReadOnlyDictionary<string, string> columnNameMappings)
    {
        if (columnNameMappings == null)
        {
            return columName;
        }

        return columnNameMappings.TryGetValue(columName, out var value) ? value : columName;
    }

    private static string GetDbColumnType(string name, Type type, IReadOnlyDictionary<string, string> columnTypeMappings)
    {
        if (columnTypeMappings == null)
        {
            return type.ToPostgreSQLType();
        }

        return columnTypeMappings.TryGetValue(name, out var value) ? value : type.ToPostgreSQLType();
    }
}
